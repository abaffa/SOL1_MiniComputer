0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; 74 SERIES MINICOMPUTER BIOS VERSION 1.0
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006   0000             ; MEMORY MAP
0007   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008   0000             ; 0000		ROM BEGIN
0009   0000             ; ....
0010   0000             ; 7FFF		ROM END
0011   0000             ;
0012   0000             ; 8000		RAM begin
0013   0000             ; ....
0014   0000             ; F7FF		Stack root
0015   0000             
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; I/O MAP
0018   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0019   0000             ; FF80		UART 0		(16550)
0020   0000             ; FF90		UART 1		(16550)
0021   0000             ; FFA0		RTC			(M48T02)
0022   0000             ; FFB0		PIO 0		(8255)
0023   0000             ; FFC0		PIO 1		(8255)
0024   0000             ; FFD0		IDE			(Compact Flash / PATA)
0025   0000             ; FFE0		Timer		(8253)
0026   0000             ; FFF0		BIOS CONFIGURATION NV-RAM STORE AREA
0027   0000             
0028   0000             
0029   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030   0000             ; SYSTEM CONSTANTS / EQUATIONS
0031   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0032   0000             _UART0_DATA				.equ $FF80				; data
0033   0000             _UART0_DLAB_0				.equ $FF80				; divisor latch low byte
0034   0000             _UART0_DLAB_1				.equ $FF81				; divisor latch high byte
0035   0000             _UART0_IER				.equ $FF81				; Interrupt enable register
0036   0000             _UART0_FCR				.equ $FF82				; FIFO control register
0037   0000             _UART0_LCR				.equ $FF83				; line control register
0038   0000             _UART0_LSR				.equ $FF85				; line status register
0039   0000             
0040   0000             _IDE_BASE				.equ $FFD0				; IDE BASE
0041   0000             _IDE_R0					.equ _IDE_BASE + 0		; DATA PORT
0042   0000             _IDE_R1					.equ _IDE_BASE + 1		; READ: ERROR CODE, WRITE: FEATURE
0043   0000             _IDE_R2					.equ _IDE_BASE + 2		; NUMBER OF SECTORS TO TRANSFER
0044   0000             _IDE_R3					.equ _IDE_BASE + 3		; SECTOR ADDRESS LBA 0 [0:7]
0045   0000             _IDE_R4					.equ _IDE_BASE + 4		; SECTOR ADDRESS LBA 1 [8:15]
0046   0000             _IDE_R5					.equ _IDE_BASE + 5		; SECTOR ADDRESS LBA 2 [16:23]
0047   0000             _IDE_R6					.equ _IDE_BASE + 6		; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0048   0000             _IDE_R7					.equ _IDE_BASE + 7		; READ: STATUS, WRITE: COMMAND
0049   0000             
0050   0000             _7SEG_DISPLAY				.equ $FFB0				; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0051   0000             _BIOS_POST_CTRL			.equ $FFB3				; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0052   0000             _PIO_A					.equ $FFB0		
0053   0000             _PIO_B					.equ $FFB1
0054   0000             _PIO_C					.equ $FFB2
0055   0000             _PIO_CONTROL				.equ $FFB3				; PIO CONTROL PORT
0056   0000             
0057   0000             _TIMER_C_0				.equ $FFE0				; TIMER COUNTER 0
0058   0000             _TIMER_C_1				.equ $FFE1				; TIMER COUNTER 1
0059   0000             _TIMER_C_2				.equ $FFE2				; TIMER COUNTER 2
0060   0000             _TIMER_CTRL				.equ $FFE3				; TIMER CONTROL REGISTER
0061   0000             
0062   0000             _STACK_BEGIN				.equ $F7FF				; beginning of stack
0063   0000             _GLOBAL_BASE				.equ $8000				; base of global variable block
0064   0000             
0065   0000             _IDE_BUFFER				.equ _GLOBAL_BASE
0066   0000             index: 					.equ _GLOBAL_BASE + 512
0067   0000             buffer_addr:				.equ _GLOBAL_BASE + 512 + 2
0068   0000             
0069   0000             boot_origin:				.equ _GLOBAL_BASE + 512 + 2 + 2
0070   0000             
0071   0000             _NULL					.equ 0
0072   0000             
0073   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0074   0000             ; GLOBAL SYSTEM VARIABLES
0075   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0076   0000             
0077   0000             
0078   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079   0000             ; EXTERNAL INTERRUPT TABLE
0080   0000             ; highest priority at lowest address
0081   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0082   0000 34 00       .dw INT_0
0083   0002 35 00       .dw INT_1
0084   0004 36 00       .dw INT_2
0085   0006 37 00       .dw INT_3
0086   0008 38 00       .dw INT_4
0087   000A 39 00       .dw INT_5
0088   000C 3A 00       .dw INT_6
0089   000E 3B 00       .dw INT_7
0090   0010             
0091   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0092   0010             ; RESET VECTOR DECLARATION
0093   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0094   0010 C0 01       .dw RESET_VECTOR
0095   0012             
0096   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097   0012             ;; EXCEPTION VECTOR TABLE
0098   0012             ;; total of 7 entries, starting at address $0012
0099   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0100   0012 3C 00       .dw TRAP_PRIVILEGE	
0101   0014 52 00       .dw TRAP_DIV_ZERO	
0102   0016 5F 00       .dw UNDEFINED_OPCODE
0103   0018 00 00       .dw _NULL
0104   001A 00 00       .dw _NULL
0105   001C 00 00       .dw _NULL
0106   001E 00 00       .dw _NULL
0107   0020             
0108   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0109   0020             ;; SYSTEM CALL VECTOR TABLE
0110   0020             ;; starts at address $0020
0111   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0112   0020 45 00       .dw TRAP_BREAKPOINT
0113   0022 60 00       .dw RTC_SERVICES				
0114   0024 96 00       .dw UART_SERVICES				
0115   0026 EE 00       .dw IDE_SERVICES	
0116   0028 00 00       .dw _NULL
0117   002A 00 00       .dw _NULL
0118   002C 00 00       .dw _NULL
0119   002E 00 00       .dw _NULL
0120   0030 00 00       .dw _NULL
0121   0032 00 00       .dw _NULL	
0122   0034             
0123   0034             bios_bkpt	.equ 0
0124   0034             bios_rtc		.equ 1
0125   0034             bios_uart	.equ 2
0126   0034             bios_ide		.equ 3
0127   0034             
0128   0034             .export _IDE_BUFFER
0129   0034             .export boot_origin
0130   0034             .export bios_uart
0131   0034             .export bios_ide
0132   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0133   0034             ; EXTERNAL INTERRUPTS' CODE BLOCK
0134   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0135   0034             INT_0:
0136   0034 06          	sysret
0137   0035             INT_1:
0138   0035 06          	sysret
0139   0036             INT_2:
0140   0036 06          	sysret
0141   0037             INT_3:
0142   0037 06          	sysret
0143   0038             INT_4:
0144   0038 06          	sysret
0145   0039             INT_5:
0146   0039 06          	sysret
0147   003A             INT_6:	
0148   003A 06          	sysret
0149   003B             INT_7:
0150   003B 06          	sysret
0151   003C             
0152   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0153   003C             ; EXCEPTIONS
0154   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0155   003C             
0156   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0157   003C             ; PRIVILEGE EXCEPTION
0158   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0159   003C             TRAP_PRIVILEGE:
0160   003C DA          	push d
0161   003D             
0162   003D 3B B4 05    	mov d, s_priv1
0163   0040 07 82 02    	call puts
0164   0043             
0165   0043 E7          	pop d
0166   0044             							; enable interrupts
0167   0044 06          	sysret
0168   0045             
0169   0045             
0170   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0171   0045             ; BREAKPOINT EXCEPTION
0172   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0173   0045             TRAP_BREAKPOINT:
0174   0045 D7          	push a
0175   0046 DA          	push d
0176   0047 E1          	pushf
0177   0048             	
0178   0048 3B 9C 05    	mov d, s_bkpt
0179   004B 07 82 02    	call puts
0180   004E             	
0181   004E EE          	popf
0182   004F E7          	pop d
0183   0050 E4          	pop a
0184   0051             							; enable interrupts
0185   0051 06          	sysret
0186   0052             
0187   0052             
0188   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0189   0052             ; DIVIDE BY ZERO EXCEPTION
0190   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0191   0052             TRAP_DIV_ZERO:
0192   0052 D7          	push a
0193   0053 DA          	push d
0194   0054 E1          	pushf
0195   0055             	
0196   0055 3B FC 05    	mov d, s_divzero
0197   0058 07 82 02    	call puts
0198   005B             	
0199   005B EE          	popf
0200   005C E7          	pop d
0201   005D E4          	pop a
0202   005E             							; enable interrupts
0203   005E 06          	sysret
0204   005F             
0205   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0206   005F             ; UNDEFINED OPCODE EXCEPTION
0207   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208   005F             UNDEFINED_OPCODE:
0209   005F 06          	sysret
0210   0060             	
0211   0060             
0212   0060             	
0213   0060             
0214   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0215   0060             ; RTC SERVICES INTERRUPT
0216   0060             ; RTC I/O bank = FFA0 to FFAF
0217   0060             ; FFA0 to FFA7 is scratch RAM
0218   0060             ; control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0219   0060             ; al = 0..6 -> get
0220   0060             ; al = 7..D -> set
0221   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0222   0060             RTC_SERVICES:
0223   0060 DB          	push al
0224   0061 DA          	push d
0225   0062 B9 06       	cmp al, 6
0226   0064 D1 79 00    	jgu RTC_SET
0227   0067             RTC_GET:
0228   0067 6A A9       	add al, $A9			; generate RTC address to get to address A9 of clock
0229   0069 22 FF       	mov ah, $FF		
0230   006B 3C          	mov d, a				; get to FFA9 + offset
0231   006C F2 A8 FF 40 	mov byte[$FFA8], $40		; set R bit to 1
0232   0070 1E          	mov al, [d]			; get data
0233   0071 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset R bit
0234   0075 23          	mov ah, al
0235   0076 E7          	pop d
0236   0077 E8          	pop al
0237   0078 06          	sysret
0238   0079             RTC_SET:
0239   0079 DD          	push bl
0240   007A 99          	mov bl, ah		; set data asIDE
0241   007B 6A A2       	add al, $A2		; generate RTC address to get to address A9 of clock
0242   007D 22 FF       	mov ah, $FF		
0243   007F 3C          	mov d, a		; get to FFA9 + offset
0244   0080 1B          	mov al, bl		; get data back
0245   0081 F2 A8 FF 80 	mov byte[$FFA8], $80	; set W bit to 1
0246   0085 3E          	mov [d], al		; set data
0247   0086 F2 A8 FF 00 	mov byte[$FFA8], 0		; reset write bit
0248   008A EA          	pop bl
0249   008B E7          	pop d
0250   008C E8          	pop al
0251   008D 06          	sysret
0252   008E             
0253   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0254   008E             ; INT 4
0255   008E             ; UART SERVICES INTERRUPT
0256   008E             ; al = option
0257   008E             ; ah = data
0258   008E             ; 0 = init, 1 = send, 2 = receive, 3 = receive with echo
0259   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260   008E             uart_serv_tbl:
0261   008E 9A 00       	.dw UART_INIT
0262   0090 B3 00       	.dw UART_SEND
0263   0092 C0 00       	.dw UART_RECEIVE
0264   0094 CD 00       	.dw UART_RECEIVE_E
0265   0096             UART_SERVICES:
0266   0096 FD 0A 8E 00 	jmp [uart_serv_tbl + al]
0267   009A             UART_INIT:
0268   009A F2 83 FF 83 	mov byte[_UART0_LCR], 83h			; 8 data, 1 stop, no parity	, divisor latch = 1, UART address 3 = Line Control Register
0269   009E F2 80 FF 03 	mov byte[_UART0_DLAB_0], 3			; baud = 38400, divisor latch low byte = 3
0270   00A2 F2 81 FF 00 	mov byte[_UART0_DLAB_1], 0			; divisor latch high byte = 0			
0271   00A6 F2 83 FF 03 	mov byte[_UART0_LCR], 3			; divisor latch = 0, UART address 3 = Line Control Register
0272   00AA F2 81 FF 00 	mov byte[_UART0_IER], 0			; disable all UART interrupts
0273   00AE F2 82 FF 00 	mov byte[_UART0_FCR], 0			; disable FIFO
0274   00B2 06          	sysret
0275   00B3             UART_SEND:
0276   00B3 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0277   00B6 93 20       	test al, 20h					; isolate Transmitter Empty
0278   00B8 C6 B3 00    	jz UART_SEND		
0279   00BB 1A          	mov al, ah
0280   00BC 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0281   00BF 06          	sysret
0282   00C0             UART_RECEIVE:
0283   00C0 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0284   00C3 93 01       	test al, 1					; isolate Data Ready
0285   00C5 C6 C0 00    	jz UART_RECEIVE
0286   00C8 1D 80 FF    	mov al, [_UART0_DATA]			; get character
0287   00CB 23          	mov ah, al
0288   00CC 06          	sysret
0289   00CD             UART_RECEIVE_E:
0290   00CD 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0291   00D0 93 01       	test al, 1					; isolate Data Ready
0292   00D2 C6 CD 00    	jz UART_RECEIVE_E
0293   00D5 1D 80 FF    	mov al, [_UART0_DATA]			; get character
0294   00D8 23          	mov ah, al
0295   00D9             UART_RECEIVE_E_LOOP:
0296   00D9 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0297   00DC 93 20       	test al, 20h					; isolate Transmitter Empty
0298   00DE C6 D9 00    	jz UART_RECEIVE_E_LOOP
0299   00E1 1A          	mov al, ah
0300   00E2 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0301   00E5 06          	sysret
0302   00E6             	
0303   00E6             
0304   00E6             
0305   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0306   00E6             ; IDE SERVICES INTERRUPT
0307   00E6             ; al = option
0308   00E6             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0309   00E6             ; IDE read/write sector
0310   00E6             ; 512 bytes
0311   00E6             ; user buffer pointer in D
0312   00E6             ; kernel buffer pointer = _IDE_BUFFER
0313   00E6             ; AH = number of sectors
0314   00E6             ; CB = LBA bytes 3..0
0315   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0316   00E6             ide_serv_tbl:
0317   00E6 F2 00       	.dw IDE_RESET
0318   00E8 06 01       	.dw IDE_SLEEP
0319   00EA 15 01       	.dw IDE_READ_SECT
0320   00EC 36 01       	.dw IDE_WRITE_SECT
0321   00EE             IDE_SERVICES:
0322   00EE FD 0A E6 00 	jmp [ide_serv_tbl + al]	
0323   00F2             IDE_RESET:			
0324   00F2 F2 D7 FF 04 	mov byte[_IDE_R7], 4		; RESET IDE
0325   00F6 07 87 01    	call IDE_wait				; wait for IDE ready			 			
0326   00F9 F2 D6 FF E0 	mov byte[_IDE_R6], $E0		; LBA3= 0, MASTER, MODE= LBA				
0327   00FD F2 D1 FF 01 	mov byte[_IDE_R1], 1		; 8-BIT TRANSFERS			
0328   0101 F2 D7 FF EF 	mov byte[_IDE_R7], $EF		; SET FEATURE COMMAND
0329   0105 06          	sysret
0330   0106             IDE_SLEEP:
0331   0106 07 87 01    	call IDE_wait					; wait for IDE ready			 			
0332   0109 F2 D6 FF 40 	mov byte [_IDE_R6], %01000000	; lba[3:0](reserved), bit 6=1
0333   010D F2 D7 FF E6 	mov byte [_IDE_R7], $E6		; sleep command
0334   0111 07 87 01    	call IDE_wait					; wait for IDE ready
0335   0114 06          	sysret
0336   0115             IDE_READ_SECT:
0337   0115 1A          	mov al, ah
0338   0116 24          	mov ah, bl
0339   0117 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0340   011A 1C          	mov al, bh
0341   011B 3D D4 FF    	mov [_IDE_R4], al
0342   011E 12          	mov a, c
0343   011F 3D D5 FF    	mov [_IDE_R5], al
0344   0122 1A          	mov al, ah
0345   0123 87 0F       	and al, %00001111
0346   0125 8B E0       	or al, %11100000			; mode lba, master
0347   0127 3D D6 FF    	mov [_IDE_R6], al
0348   012A 07 87 01    	call IDE_wait
0349   012D 19 20       	mov al, 20h
0350   012F 3D D7 FF    	mov [_IDE_R7], al			; read sector cmd
0351   0132 07 57 01    	call IDE_read	
0352   0135 06          	sysret
0353   0136             IDE_WRITE_SECT:
0354   0136 1A          	mov al, ah
0355   0137 24          	mov ah, bl
0356   0138 42 D2 FF    	mov [_IDE_R2], a			; number of sectors (0..255)
0357   013B 1C          	mov al, bh
0358   013C 3D D4 FF    	mov [_IDE_R4], al
0359   013F 12          	mov a, c
0360   0140 3D D5 FF    	mov [_IDE_R5], al
0361   0143 1A          	mov al, ah
0362   0144 87 0F       	and al, %00001111
0363   0146 8B E0       	or al, %11100000			; mode lba, master
0364   0148 3D D6 FF    	mov [_IDE_R6], al
0365   014B 07 87 01    	call IDE_wait
0366   014E 19 30       	mov al, 30h
0367   0150 3D D7 FF    	mov [_IDE_R7], al			; write sector cmd
0368   0153 07 6F 01    	call IDE_write			
0369   0156 06          	sysret
0370   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0371   0157             ; READ IDE DATA
0372   0157             ; pointer in D
0373   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0374   0157             IDE_read:
0375   0157 DB          	push al
0376   0158 DA          	push d
0377   0159             IDE_read_loop:
0378   0159 07 87 01    	call IDE_wait
0379   015C 1D D7 FF    	mov al, [_IDE_R7]
0380   015F 87 08       	and al, %00001000			; DRQ FLAG
0381   0161 C6 6C 01    	jz IDE_read_end
0382   0164 1D D0 FF    	mov al, [_IDE_R0]
0383   0167 3E          	mov [d], al
0384   0168 79          	inc d
0385   0169 0A 59 01    	jmp IDE_read_loop
0386   016C             IDE_read_end:
0387   016C E7          	pop d
0388   016D E8          	pop al
0389   016E 09          	ret
0390   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0391   016F             ; WRITE IDE DATA
0392   016F             ; data pointer in D
0393   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0394   016F             IDE_write:
0395   016F DB          	push al
0396   0170 DA          	push d
0397   0171             IDE_write_loop:
0398   0171 07 87 01    	call IDE_wait
0399   0174 1D D7 FF    	mov al, [_IDE_R7]
0400   0177 87 08       	and al, %00001000			; DRQ FLAG
0401   0179 C6 84 01    	jz IDE_write_end
0402   017C 1E          	mov al, [d]
0403   017D 3D D0 FF    	mov [_IDE_R0], al
0404   0180 79          	inc d 
0405   0181 0A 71 01    	jmp IDE_write_loop
0406   0184             IDE_write_end:
0407   0184 E7          	pop d
0408   0185 E8          	pop al
0409   0186 09          	ret
0410   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0411   0187             ; wait for IDE to be ready
0412   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0413   0187             IDE_wait:
0414   0187 1D D7 FF    	mov al, [_IDE_R7]	
0415   018A 87 80       	and al, 80h				; BUSY FLAG
0416   018C C7 87 01    	jnz IDE_wait
0417   018F 09          	ret
0418   0190             
0419   0190             	
0420   0190             	
0421   0190             ; ************************************************************
0422   0190             ; GET HEX FILE
0423   0190             ; di = destination address
0424   0190             ; return length in bytes in C
0425   0190             ; ************************************************************
0426   0190             _load_hex:
0427   0190 D2          	push bp
0428   0191 9B          	mov bp, sp
0429   0192 D7          	push a
0430   0193 D8          	push b
0431   0194 DA          	push d
0432   0195 E2          	push si
0433   0196 E3          	push di
0434   0197 52 00 60    	sub sp, $6000				; string data block
0435   019A 38 00 00    	mov c, 0
0436   019D             	
0437   019D 48          	mov a, sp
0438   019E 77          	inc a
0439   019F 3C          	mov d, a				; start of string data block
0440   01A0 07 F5 02    	call getse				; get program string
0441   01A3 4D          	mov si, a
0442   01A4             
0443   01A4             __load_hex_loop:
0444   01A4 F6          	lodsb					; load from [SI] to AL
0445   01A5 B9 00       	cmp al, 0				; check if ASCII 0
0446   01A7 C6 B5 01    	jz __load_hex_ret
0447   01AA 36          	mov bh, al
0448   01AB F6          	lodsb
0449   01AC 2F          	mov bl, al
0450   01AD 07 5E 03    	call atoi				; convert ASCII byte in B to int (to AL)
0451   01B0 F7          	stosb					; store AL to [DI]
0452   01B1 78          	inc c
0453   01B2 0A A4 01    	jmp __load_hex_loop
0454   01B5             __load_hex_ret:
0455   01B5 51 00 60    	add sp, $6000
0456   01B8 F0          	pop di
0457   01B9 EF          	pop si
0458   01BA E7          	pop d
0459   01BB E5          	pop b
0460   01BC E4          	pop a
0461   01BD 9C          	mov sp, bp
0462   01BE F1          	pop bp
0463   01BF 09          	ret
0464   01C0             	
0465   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0466   01C0             ; BIOS ENTRY POINT
0467   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0468   01C0             RESET_VECTOR:
0469   01C0 19 20       	mov al, %00100000				; interrupts = OFF, mode = SUP, paging = OFF, halt-flag = OFF, display_load = ON
0470   01C2 0D          	stostat
0471   01C3             	
0472   01C3 10 FF F7    	mov a, _STACK_BEGIN
0473   01C6 47          	mov sp, a
0474   01C7 49          	mov bp, a			; setup stack and frame
0475   01C8             
0476   01C8 19 00       	mov al, 0
0477   01CA 05 02       	syscall bios_uart
0478   01CC             	
0479   01CC 3B EA 03    	mov d, s_welcome
0480   01CF 07 82 02    	call puts					; print welcome msg
0481   01D2             
0482   01D2 07 F2 01    	call BIOS_peripherals_setup
0483   01D5             	
0484   01D5             
0485   01D5 3B 3D 04    	mov d, s_boot1
0486   01D8 07 82 02    	call puts
0487   01DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0488   01DB             ; we read the first kernel sector, in order to obtain the reset vector at location $10
0489   01DB 38 00 00    	mov c, 0
0490   01DE 26 00 00    	mov b, 0					; start at disk sector 0
0491   01E1 3B 04 82    	mov d, boot_origin		; we read into the bios ide buffer
0492   01E4 10 02 01    	mov a, $0102				; disk read, 1 sector
0493   01E7 05 03       	syscall bios_ide			; read sector	
0494   01E9             	
0495   01E9 3B 53 04    	mov d, s_boot2
0496   01EC 07 82 02    	call puts
0497   01EF             
0498   01EF 0A 04 82    	jmp boot_origin
0499   01F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0500   01F2             
0501   01F2             BIOS_peripherals_setup:
0502   01F2 3B AD 04    	mov d, s_init
0503   01F5 07 82 02    	call puts
0504   01F8             	
0505   01F8 3B 66 04    	mov d, s_bios3
0506   01FB 07 82 02    	call puts
0507   01FE 19 00       	mov al, 0						; reset ide
0508   0200 05 03       	syscall bios_ide	
0509   0202             	
0510   0202 3B 7C 04    	mov d, s_bios4
0511   0205 07 82 02    	call puts
0512   0208             	
0513   0208 19 30       	mov al, %00110000					; counter 0, load both bytes, mode 0, binary
0514   020A 3D E3 FF    	mov [_TIMER_CTRL], al
0515   020D 19 FF       	mov al, $FF
0516   020F 3D E0 FF    	mov [_TIMER_C_0], al				; load counter 0 low byte
0517   0212 3D E0 FF    	mov [_TIMER_C_0], al				; load counter 0 high byte
0518   0215             	
0519   0215 3B 92 04    	mov d, s_bios5
0520   0218 07 82 02    	call puts
0521   021B 19 80       	mov al, $80
0522   021D 3D B3 FF    	mov [_BIOS_POST_CTRL], al			; set PIO_A to output mode
0523   0220 19 00       	mov al, 0
0524   0222 3D B0 FF    	mov [_7SEG_DISPLAY], al			; post code = 00
0525   0225 09          	ret
0526   0226             
0527   0226             
0528   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0529   0226             ; PRINT 16BIT HEX INTEGER
0530   0226             ; integer value in reg B
0531   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0532   0226             PRINT_U16X:
0533   0226 E1          	pushf
0534   0227 D7          	push a
0535   0228 D8          	push b
0536   0229 DD          	push bl
0537   022A 30          	mov bl, bh
0538   022B 07 70 03    	call itoa				; convert bh to char in A
0539   022E 2F          	mov bl, al				; save al	
0540   022F 19 01       	mov al, 1
0541   0231 05 02       	syscall bios_uart				; display AH
0542   0233 24          	mov ah, bl				; retrieve al
0543   0234 19 01       	mov al, 1
0544   0236 05 02       	syscall bios_uart				; display AL
0545   0238             
0546   0238 EA          	pop bl
0547   0239 07 70 03    	call itoa				; convert bh to char in A
0548   023C 2F          	mov bl, al				; save al
0549   023D 19 01       	mov al, 1
0550   023F 05 02       	syscall bios_uart				; display AH
0551   0241 24          	mov ah, bl				; retrieve al
0552   0242 19 01       	mov al, 1
0553   0244 05 02       	syscall bios_uart				; display AL
0554   0246             
0555   0246 E5          	pop b
0556   0247 E4          	pop a
0557   0248 EE          	popf
0558   0249 09          	ret
0559   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0560   024A             ; INPUT 16BIT HEX INTEGER
0561   024A             ; read 16bit integer into A
0562   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563   024A             SCAN_U16X:
0564   024A F8 10 00    	enter 16
0565   024D E1          	pushf
0566   024E D8          	push b
0567   024F DA          	push d
0568   0250             
0569   0250 FA F1 FF    	lea d, [bp + -15]
0570   0253 07 F5 02    	call getse				; get number
0571   0256             
0572   0256 32          	mov bl, [d]
0573   0257 37          	mov bh, bl
0574   0258 33 01 00    	mov bl, [d + 1]
0575   025B 07 5E 03    	call atoi				; convert to int in AL
0576   025E 23          	mov ah, al				; move to AH
0577   025F             	
0578   025F 33 02 00    	mov bl, [d + 2]
0579   0262 37          	mov bh, bl
0580   0263 33 03 00    	mov bl, [d + 3]
0581   0266 07 5E 03    	call atoi				; convert to int in AL
0582   0269             	
0583   0269 E7          	pop d	
0584   026A E5          	pop b
0585   026B EE          	popf
0586   026C F9          	leave
0587   026D 09          	ret
0588   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0589   026E             ; PRINT 8BIT HEX INTEGER
0590   026E             ; byte value in reg BL
0591   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592   026E             XPUT_U8:
0593   026E D7          	push a
0594   026F DD          	push bl
0595   0270 E1          	pushf
0596   0271             
0597   0271 07 70 03    	call itoa					; convert bl to char in A
0598   0274 2F          	mov bl, al					; save al	
0599   0275 19 01       	mov al, 1
0600   0277 05 02       	syscall bios_uart				; display AH
0601   0279 24          	mov ah, bl					; retrieve al
0602   027A 19 01       	mov al, 1
0603   027C 05 02       	syscall bios_uart				; display AL
0604   027E             	
0605   027E EE          	popf
0606   027F EA          	pop bl
0607   0280 E4          	pop a
0608   0281 09          	ret
0609   0282             
0610   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0611   0282             ; PRINT NULL TERMINATED STRING
0612   0282             ; pointer in D
0613   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0614   0282             puts:
0615   0282 D7          	push a
0616   0283 DA          	push d
0617   0284 E1          	pushf
0618   0285             puts_L1:
0619   0285 1E          	mov al, [d]
0620   0286 B9 00       	cmp al, 0
0621   0288 C6 9B 02    	jz puts_end
0622   028B             puts_L2:
0623   028B 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0624   028E 93 20       	test al, $20					; isolate Transmitter Empty
0625   0290 C6 8B 02    	jz puts_L2		
0626   0293 1E          	mov al, [d]
0627   0294 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0628   0297 79          	inc d	
0629   0298 0A 85 02    	jmp puts_L1
0630   029B             puts_end:
0631   029B EE          	popf
0632   029C E7          	pop d
0633   029D E4          	pop a
0634   029E 09          	ret
0635   029F             
0636   029F             
0637   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0638   029F             ; putchar
0639   029F             ; char in ah
0640   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0641   029F             putchar:
0642   029F D7          	push a
0643   02A0 E1          	pushf
0644   02A1             putchar_L1:
0645   02A1 1D 85 FF    	mov al, [_UART0_LSR]			; read Line Status Register
0646   02A4 93 20       	test al, 20h					; isolate Transmitter Empty
0647   02A6 C6 A1 02    	jz putchar_L1		
0648   02A9 1A          	mov al, ah
0649   02AA 3D 80 FF    	mov [_UART0_DATA], al			; write char to Transmitter Holding Register
0650   02AD EE          	popf
0651   02AE E4          	pop a
0652   02AF 09          	ret
0653   02B0             	
0654   02B0             	
0655   02B0             	
0656   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0657   02B0             ;; INPUT A STRING with no echo
0658   02B0             ;; terminates with null
0659   02B0             ;; pointer in D
0660   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0661   02B0             gets:
0662   02B0 E1          	pushf
0663   02B1 D7          	push a
0664   02B2 DA          	push d
0665   02B3             gets_loop:
0666   02B3 19 02       	mov al, 2
0667   02B5 05 02       	syscall bios_uart			; receive in AH
0668   02B7 76 0A       	cmp ah, 0Ah				; LF
0669   02B9 C6 EE 02    	je gets_end
0670   02BC 76 0D       	cmp ah, 0Dh				; CR
0671   02BE C6 EE 02    	je gets_end
0672   02C1 76 5C       	cmp ah, $5C				; '\\'
0673   02C3 C6 CC 02    	je gets_escape
0674   02C6 1A          	mov al, ah
0675   02C7 3E          	mov [d], al
0676   02C8 79          	inc d
0677   02C9 0A B3 02    	jmp gets_loop
0678   02CC             gets_escape:
0679   02CC 19 02       	mov al, 2
0680   02CE 05 02       	syscall bios_uart			; receive in AH
0681   02D0 76 6E       	cmp ah, 'n'
0682   02D2 C6 E0 02    	je gets_LF
0683   02D5 76 72       	cmp ah, 'r'
0684   02D7 C6 E7 02    	je gets_CR
0685   02DA 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0686   02DB 3E          	mov [d], al
0687   02DC 79          	inc d
0688   02DD 0A B3 02    	jmp gets_loop
0689   02E0             gets_LF:
0690   02E0 19 0A       	mov al, $0A
0691   02E2 3E          	mov [d], al
0692   02E3 79          	inc d
0693   02E4 0A B3 02    	jmp gets_loop
0694   02E7             gets_CR:
0695   02E7 19 0D       	mov al, $0D
0696   02E9 3E          	mov [d], al
0697   02EA 79          	inc d
0698   02EB 0A B3 02    	jmp gets_loop
0699   02EE             gets_end:
0700   02EE 19 00       	mov al, 0
0701   02F0 3E          	mov [d], al				; terminate string
0702   02F1 E7          	pop d
0703   02F2 E4          	pop a
0704   02F3 EE          	popf
0705   02F4 09          	ret
0706   02F5             
0707   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0708   02F5             ;; INPUT A STRING with echo
0709   02F5             ;; terminates with null
0710   02F5             ;; pointer in D
0711   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0712   02F5             getse:
0713   02F5 E1          	pushf
0714   02F6 D7          	push a
0715   02F7 DA          	push d
0716   02F8             getse_loop:
0717   02F8 19 03       	mov al, 3
0718   02FA 05 02       	syscall bios_uart			; receive in AH
0719   02FC 76 0A       	cmp ah, 0Ah				; LF
0720   02FE C6 33 03    	je getse_end
0721   0301 76 0D       	cmp ah, 0Dh				; CR
0722   0303 C6 33 03    	je getse_end
0723   0306 76 5C       	cmp ah, $5C				; '\\'
0724   0308 C6 11 03    	je getse_escape
0725   030B 1A          	mov al, ah
0726   030C 3E          	mov [d], al
0727   030D 79          	inc d
0728   030E 0A F8 02    	jmp getse_loop
0729   0311             getse_escape:
0730   0311 19 03       	mov al, 3
0731   0313 05 02       	syscall bios_uart			; receive in AH
0732   0315 76 6E       	cmp ah, 'n'
0733   0317 C6 25 03    	je getse_LF
0734   031A 76 72       	cmp ah, 'r'
0735   031C C6 2C 03    	je getse_CR
0736   031F 1A          	mov al, ah				; if not a known escape, it is just a normal letter
0737   0320 3E          	mov [d], al
0738   0321 79          	inc d
0739   0322 0A F8 02    	jmp getse_loop
0740   0325             getse_LF:
0741   0325 19 0A       	mov al, $0A
0742   0327 3E          	mov [d], al
0743   0328 79          	inc d
0744   0329 0A F8 02    	jmp getse_loop
0745   032C             getse_CR:
0746   032C 19 0D       	mov al, $0D
0747   032E 3E          	mov [d], al
0748   032F 79          	inc d
0749   0330 0A F8 02    	jmp getse_loop
0750   0333             getse_end:
0751   0333 19 00       	mov al, 0
0752   0335 3E          	mov [d], al				; terminate string
0753   0336 E7          	pop d
0754   0337 E4          	pop a
0755   0338 EE          	popf
0756   0339 09          	ret
0757   033A             
0758   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0759   033A             ; PRINT NEW LINE
0760   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0761   033A             put_nl:
0762   033A E1          	pushf
0763   033B D7          	push a
0764   033C 10 01 0A    	mov a, $0A01
0765   033F 05 02       	syscall bios_uart
0766   0341 10 01 0D    	mov a, $0D01
0767   0344 05 02       	syscall bios_uart
0768   0346 E4          	pop a
0769   0347 EE          	popf
0770   0348 09          	ret
0771   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0772   0349             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0773   0349             ; ASCII in BL
0774   0349             ; result in AL
0775   0349             ; ascii for F = 0100 0110
0776   0349             ; ascii for 9 = 0011 1001
0777   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0778   0349             hex_ascii_encode:
0779   0349 1B          	mov al, bl	
0780   034A 93 40       	test al, 40h				; test if letter or number
0781   034C C7 52 03    	jnz hex_letter
0782   034F 87 0F       	and al, 0Fh				; get number
0783   0351 09          	ret
0784   0352             hex_letter:
0785   0352 DC          	push ah
0786   0353 24          	mov ah, bl
0787   0354 07 AD 03    	call to_upper
0788   0357 1A          	mov al, ah	
0789   0358 87 0F       	and al, 0Fh				; get letter
0790   035A 6A 09       	add al, 9
0791   035C E9          	pop ah
0792   035D 09          	ret
0793   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0794   035E             ; ATOI
0795   035E             ; 2 letter hex string in B
0796   035E             ; 8bit integer returned in AL
0797   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0798   035E             atoi:
0799   035E E1          	pushf
0800   035F D8          	push b
0801   0360             		
0802   0360 07 49 03    	call hex_ascii_encode			; convert BL to 4bit code in AL
0803   0363 30          	mov bl, bh
0804   0364 DB          	push al					; save a
0805   0365 07 49 03    	call hex_ascii_encode
0806   0368 EA          	pop bl	
0807   0369 FD 9E 04    	shl al, 4
0808   036C 8C          	or al, bl
0809   036D             	
0810   036D E5          	pop b
0811   036E EE          	popf
0812   036F 09          	ret	
0813   0370             
0814   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0815   0370             ; ITOA
0816   0370             ; 8bit value in BL
0817   0370             ; 2 byte ASCII result in A
0818   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0819   0370             itoa:
0820   0370 E1          	pushf
0821   0371 DA          	push d
0822   0372 DE          	push	bh
0823   0373 DD          	push bl
0824   0374             
0825   0374 A7 00       	mov bh, 0
0826   0376             	
0827   0376 FD 87 0F    	and 	bl, $0F
0828   0379 3B 8C 05    	mov 	d, s_hex_digits
0829   037C 5A          	add 	d, b
0830   037D 1E          	mov 	al, [d]				; get ASCII
0831   037E EA          	pop 	bl
0832   037F 52 01 00    	sub sp, 1				; push bl back
0833   0382 DB          	push al
0834   0383             	
0835   0383 FD 87 F0    	and 	bl, $F0
0836   0386 FD A4 04    	shr 	bl, 4
0837   0389 3B 8C 05    	mov 	d, s_hex_digits
0838   038C 5A          	add 	d, b
0839   038D 1E          	mov 	al, [d]				; get ASCII
0840   038E             
0841   038E 23          	mov ah, al
0842   038F E8          	pop 	al	
0843   0390             	
0844   0390 EA          	pop 	bl
0845   0391 EB          	pop bh
0846   0392 E7          	pop 	d
0847   0393 EE          	popf
0848   0394 09          	ret
0849   0395             
0850   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0851   0395             ; STRCMP
0852   0395             ; compare two strings
0853   0395             ; str1 in SI
0854   0395             ; str2 in DI
0855   0395             ; changes: AL SI DI
0856   0395             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0857   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0858   0395             strcmp:
0859   0395             strcmp_loop:
0860   0395 F3          	cmpsb					; compare a byte of the strings
0861   0396 C7 A2 03    	jne strcmp_ret
0862   0399 FB FF FF    	lea d, [si + -1]
0863   039C 1E          	mov al, [d]
0864   039D B9 00       	cmp al, 0				; check if at end of string (null)
0865   039F C7 95 03    	jne strcmp_loop				; equal chars but not at end
0866   03A2             strcmp_ret:				
0867   03A2 09          	ret
0868   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0869   03A3             ; TO LOWER
0870   03A3             ; input in AL
0871   03A3             ; output in AL
0872   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0873   03A3             to_lower:
0874   03A3 E1          	pushf
0875   03A4 B9 5A       	cmp al, 'Z'
0876   03A6 D1 AB 03    	jgu to_lower_ret
0877   03A9 6A 20       	add al, 20h				; convert to lower case
0878   03AB             to_lower_ret:
0879   03AB EE          	popf
0880   03AC 09          	ret
0881   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0882   03AD             ; TO UPPER
0883   03AD             ; input in AL
0884   03AD             ; output in AL
0885   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0886   03AD             to_upper:
0887   03AD E1          	pushf
0888   03AE B9 61       	cmp al, 'a'
0889   03B0 C8 B5 03    	jlu to_upper_ret
0890   03B3 6F 20       	sub al, 20h				; convert to upper case
0891   03B5             to_upper_ret:
0892   03B5 EE          	popf
0893   03B6 09          	ret
0894   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0895   03B7             ; PRINT DECIMAL INTEGER
0896   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0897   03B7             print_decimal:
0898   03B7 09          	ret
0899   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0900   03B8             ; GET HEX FILE
0901   03B8             ; di = destination address
0902   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0903   03B8             load_hex:
0904   03B8 F8 00 60    	enter $6000
0905   03BB             	
0906   03BB 10 00 90    	mov a, $9000					; destination
0907   03BE 4F          	mov di, a	
0908   03BF             						; string data block
0909   03BF FA 01 A0    	lea d, [bp + -24575]			; start of string data block
0910   03C2 07 F5 02    	call getse					; get program string
0911   03C5 13          	mov a, d
0912   03C6 4D          	mov si, a
0913   03C7             load_hex_loop:
0914   03C7 F6          	lodsb					; load from [SI] to AL
0915   03C8 B9 00       	cmp al, 0				; check if ASCII 0
0916   03CA C6 D7 03    	jz load_hex_ret
0917   03CD 36          	mov bh, al
0918   03CE F6          	lodsb
0919   03CF 2F          	mov bl, al
0920   03D0 07 5E 03    	call atoi				; convert ASCII byte in B to int (to AL)
0921   03D3 F7          	stosb					; store AL to [DI]
0922   03D4 0A C7 03    	jmp load_hex_loop
0923   03D7             load_hex_ret:
0924   03D7 F9          	leave
0925   03D8 09          	ret
0926   03D9             
0927   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0928   03D9             ; HEX STRING TO BINARY
0929   03D9             ; di = destination address
0930   03D9             ; si = source
0931   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0932   03D9             hex_to_int:
0933   03D9             hex_to_int_L1:
0934   03D9 F6          	lodsb					; load from [SI] to AL
0935   03DA B9 00       	cmp al, 0				; check if ASCII 0
0936   03DC C6 E9 03    	jz hex_to_int_ret
0937   03DF 36          	mov bh, al
0938   03E0 F6          	lodsb
0939   03E1 2F          	mov bl, al
0940   03E2 07 5E 03    	call atoi				; convert ASCII byte in B to int (to AL)
0941   03E5 F7          	stosb					; store AL to [DI]
0942   03E6 0A D9 03    	jmp hex_to_int_L1
0943   03E9             hex_to_int_ret:
0944   03E9 09          	ret	
0945   03EA             		
0946   03EA             
0947   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0948   03EA             ; DATA BLOCK
0949   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0950   03EA 0A 0A 0D 53 s_welcome:		.db "\n\n\rSol-1 74HC HomebrewCPU MiniComputer\n"
0950   03EE 6F 6C 2D 31 
0950   03F2 20 37 34 48 
0950   03F6 43 20 48 6F 
0950   03FA 6D 65 62 72 
0950   03FE 65 77 43 50 
0950   0402 55 20 4D 69 
0950   0406 6E 69 43 6F 
0950   040A 6D 70 75 74 
0950   040E 65 72 0A 
0951   0411 42 49 4F 53 				.db "BIOS Version 0.1\n\n\r"
0951   0415 20 56 65 72 
0951   0419 73 69 6F 6E 
0951   041D 20 30 2E 31 
0951   0421 0A 0A 0D 
0952   0424 74 65 72 6D 				.db "terminal-1 initialized\n\r", 0
0952   0428 69 6E 61 6C 
0952   042C 2D 31 20 69 
0952   0430 6E 69 74 69 
0952   0434 61 6C 69 7A 
0952   0438 65 64 0A 0D 
0952   043C 00 
0953   043D             				
0954   043D 72 65 61 64 s_boot1:			.db "reading boot sector\n\r", 0
0954   0441 69 6E 67 20 
0954   0445 62 6F 6F 74 
0954   0449 20 73 65 63 
0954   044D 74 6F 72 0A 
0954   0451 0D 00 
0955   0453 62 6F 6F 74 s_boot2:			.db "boot-sector read\n\r", 0
0955   0457 2D 73 65 63 
0955   045B 74 6F 72 20 
0955   045F 72 65 61 64 
0955   0463 0A 0D 00 
0956   0466             
0957   0466             				
0958   0466 72 65 73 65 s_bios3: 		.db "resetting IDE-drive\n\r", 0
0958   046A 74 74 69 6E 
0958   046E 67 20 49 44 
0958   0472 45 2D 64 72 
0958   0476 69 76 65 0A 
0958   047A 0D 00 
0959   047C 63 6F 6E 66 s_bios4: 		.db "configuring Timer-1\n\r", 0
0959   0480 69 67 75 72 
0959   0484 69 6E 67 20 
0959   0488 54 69 6D 65 
0959   048C 72 2D 31 0A 
0959   0490 0D 00 
0960   0492 50 49 4F 2D s_bios5:	 		.db "PIO-A set to output mode\n\r", 0
0960   0496 41 20 73 65 
0960   049A 74 20 74 6F 
0960   049E 20 6F 75 74 
0960   04A2 70 75 74 20 
0960   04A6 6D 6F 64 65 
0960   04AA 0A 0D 00 
0961   04AD             
0962   04AD 65 6E 74 65 s_init:			.db "entering real-mode [supervisor on; paging off]\n\r"
0962   04B1 72 69 6E 67 
0962   04B5 20 72 65 61 
0962   04B9 6C 2D 6D 6F 
0962   04BD 64 65 20 5B 
0962   04C1 73 75 70 65 
0962   04C5 72 76 69 73 
0962   04C9 6F 72 20 6F 
0962   04CD 6E 3B 20 70 
0962   04D1 61 67 69 6E 
0962   04D5 67 20 6F 66 
0962   04D9 66 5D 0A 0D 
0963   04DD 69 6E 74 65 				.db "interrupts disabled\n\r"
0963   04E1 72 72 75 70 
0963   04E5 74 73 20 64 
0963   04E9 69 73 61 62 
0963   04ED 6C 65 64 0A 
0963   04F1 0D 
0964   04F2 64 69 73 70 				.db "display register loading enabled\n\r", 0
0964   04F6 6C 61 79 20 
0964   04FA 72 65 67 69 
0964   04FE 73 74 65 72 
0964   0502 20 6C 6F 61 
0964   0506 64 69 6E 67 
0964   050A 20 65 6E 61 
0964   050E 62 6C 65 64 
0964   0512 0A 0D 00 
0965   0515             
0966   0515 0A          s_nl_2:			.db "\n"
0967   0516 0A 0D 00    s_nl_1:			.db "\n\r", 0
0968   0519             
0969   0519 64 61 74 61 s_enter_prog:		.db "data: ", 0
0969   051D 3A 20 00 
0970   0520 6F 72 69 67 s_origin_addr:	.db "origin address: ", 0
0970   0524 69 6E 20 61 
0970   0528 64 64 72 65 
0970   052C 73 73 3A 20 
0970   0530 00 
0971   0531             
0972   0531 53 65 72 69 s_IDE_serial:		.db "Serial: ", 0
0972   0535 61 6C 3A 20 
0972   0539 00 
0973   053A 46 69 72 6D s_IDE_firm:		.db "Firmware: ", 0
0973   053E 77 61 72 65 
0973   0542 3A 20 00 
0974   0545 4D 6F 64 65 s_IDE_model:		.db "Model: ", 0
0974   0549 6C 3A 20 00 
0975   054D 4E 75 6D 62 s_sectors:		.db "Number of sectors: ", 0
0975   0551 65 72 20 6F 
0975   0555 66 20 73 65 
0975   0559 63 74 6F 72 
0975   055D 73 3A 20 00 
0976   0561 4C 42 41 20 s_LBA0:			.db "LBA 0: ", 0
0976   0565 30 3A 20 00 
0977   0569 4C 42 41 20 s_LBA1:			.db "LBA 1: ", 0
0977   056D 31 3A 20 00 
0978   0571 4C 42 41 20 s_LBA2:			.db "LBA 2: ", 0
0978   0575 32 3A 20 00 
0979   0579 4C 42 41 20 s_LBA3:			.db "LBA 3: ", 0
0979   057D 33 3A 20 00 
0980   0581 0A 0D 45 72 s_error:			.db "\n\rError.\n\r", 0
0980   0585 72 6F 72 2E 
0980   0589 0A 0D 00 
0981   058C             
0982   058C 30 31 32 33 s_hex_digits:		.db "0123456789ABCDEF"
0982   0590 34 35 36 37 
0982   0594 38 39 41 42 
0982   0598 43 44 45 46 
0983   059C 74 68 69 73 s_bkpt: 			.db "this is the breakpoint.", 0
0983   05A0 20 69 73 20 
0983   05A4 74 68 65 20 
0983   05A8 62 72 65 61 
0983   05AC 6B 70 6F 69 
0983   05B0 6E 74 2E 00 
0984   05B4             
0985   05B4             
0986   05B4 0A 0A 0D 73 s_priv1:			.db "\n\n\rsoftware failure: privilege exception "
0986   05B8 6F 66 74 77 
0986   05BC 61 72 65 20 
0986   05C0 66 61 69 6C 
0986   05C4 75 72 65 3A 
0986   05C8 20 70 72 69 
0986   05CC 76 69 6C 65 
0986   05D0 67 65 20 65 
0986   05D4 78 63 65 70 
0986   05D8 74 69 6F 6E 
0986   05DC 20 
0987   05DD 70 72 65 73 				.db "press any key to continue...\n\r", 0
0987   05E1 73 20 61 6E 
0987   05E5 79 20 6B 65 
0987   05E9 79 20 74 6F 
0987   05ED 20 63 6F 6E 
0987   05F1 74 69 6E 75 
0987   05F5 65 2E 2E 2E 
0987   05F9 0A 0D 00 
0988   05FC 0A 0D 65 78 s_divzero:		.db "\n\rexception: zero division\n\r", 0
0988   0600 63 65 70 74 
0988   0604 69 6F 6E 3A 
0988   0608 20 7A 65 72 
0988   060C 6F 20 64 69 
0988   0610 76 69 73 69 
0988   0614 6F 6E 0A 0D 
0988   0618 00 
0989   0619             
0990   0619             
0991   0619             
0992   0619             
0993   0619             
0994   0619             
0995   0619             .end
tasm: Number of errors = 0
